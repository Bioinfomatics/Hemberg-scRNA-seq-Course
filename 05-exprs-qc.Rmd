---
knit: bookdown::preview_chapter
---

# Expression QC (UMI)

## Introduction

Once gene expression has been quantified it is summarized as an __expression matrix__ where each row corresponds to a gene (or transcript) and each column corresponds to a single cell. This matrix should be examined to remove poor quality cells which were not evident in either read QC or mapping QC. Failure to remove low quality cells at this
stage will add a large amount of technical noise which will obscure
the biological signals of interest in downstream analysis. 

Since there is currently no standard method for performing scRNASeq the expected values for the various QC measures that will be presented here can vary substantially from experiment to experiment. Thus, to perform QC we will be looking for cells which are outliers with respect to the rest of the dataset rather than comparing to independent quality standards.

For convience we will also be using the [scater](https://github.com/davismcc/scater) package which contains many functions to aid in quality control.

## Blischak dataset

To illustrate cell QC, we consider a
[dataset](http://jdblischak.github.io/singleCellSeq/analysis/) of
 induced pluripotent stem cells generated from three different individuals by John
Blischak in [Yoav Gilad](http://giladlab.uchicago.edu/)'s lab at the
University of Chicago. The experiments were carried out on the
Fluidigm C1 platform and to facilitate the quantification both unique
molecular identifiers (UMIs) and ERCC _spike-ins_ were used. For our purposes you need to download the files `annotation.txt`, `molecules.txt`, and `reads.txt` from [here](http://genat.uk/bookdown-demo/blischak) into the `blischak` folder in your working directory. These files are the copies of the original files made on the 15/03/16. We will use these copies for reproducibility purposes.

```{r, echo=FALSE}
library(knitr)
opts_chunk$set(out.width='90%', fig.align = 'center')
```

```{r, message=FALSE, warning=FALSE}
library(scater, quietly = TRUE)
options(stringsAsFactors = FALSE)
```

Load the data and annotations:
```{r}
molecules <- read.table("blischak/molecules.txt", sep = "\t")
anno <- read.table("blischak/annotation.txt", sep = "\t", header = TRUE)
```

How does the data look like?
```{r}
knitr::kable(
    head(molecules[ , 1:3]), booktabs = TRUE,
    caption = 'A table of the first 6 rows and 3 columns of the molecules table.'
)
knitr::kable(
    head(anno), booktabs = TRUE,
    caption = 'A table of the first 6 rows of the anno table.'
)
```

The data consists of `r length(unique(anno$individual))` individuals and `r length(unique(anno$replicate))` replicates and therefore has `r length(unique(anno$batch))` batches in total.

Let's standardise the analysis by using the scater package described above. First, make scater SCESet classes:
```{r}
pheno_data <- new("AnnotatedDataFrame", anno)
rownames(pheno_data) <- pheno_data$sample_id
umi <- scater::newSCESet(
    countData = molecules,
    phenoData = pheno_data
)
```

Remove genes that are not expressed in any cell:
```{r}
keep_feature <- rowSums(is_exprs(umi)) > 0
umi <- umi[keep_feature, ]
```

Define control features (genes) - ERCC spike-ins and mitochondrial genes ([provided](http://jdblischak.github.io/singleCellSeq/analysis/qc-filter-ipsc.html) by the authors):
```{r}
ercc <- featureNames(umi)[grepl("ERCC-", featureNames(umi))]
mt <- c("ENSG00000198899", "ENSG00000198727", "ENSG00000198888",
        "ENSG00000198886", "ENSG00000212907", "ENSG00000198786",
        "ENSG00000198695", "ENSG00000198712", "ENSG00000198804",
        "ENSG00000198763", "ENSG00000228253", "ENSG00000198938",
        "ENSG00000198840")
```

Calculate the quality metrics:
```{r}
umi <- scater::calculateQCMetrics(
    umi,
    feature_controls = list(ERCC = ercc, MT = mt)
)
```


## Cell QC

### Library size

Next we will look at the total number of RNA molecules detected per
sample (if we were using read counts rather than UMI counts this would
be total reads). Wells with few reads/molecules are likely to have
been broken or failed to capture a cell, thus should be removed.

```{r total-counts-hist, fig.cap = "Histogram of library sizes for all cells"}
hist(
    umi$total_counts,
    breaks = 100
)
abline(v = 25000, col = "red")
```

__Exercise__

Apply a suitable filter to remove the cells that
contain too few molecules. What distribution do you expect that the
total number of molecules for each cell should follow?

__Answer__
```{r}
filter_by_total_counts <- (umi$total_counts > 25000)
```

```{r}
knitr::kable(
    as.data.frame(table(filter_by_total_counts)),
    booktabs = TRUE,
    row.names = FALSE,
    caption = 'The number of cells removed by total counts filter (FALSE)'
)
```

### Detected genes (1)

One of the simplest measures of cell quality is the number of genes
that were detected. Cells with few detected genes may have been broken
or dead prior to capture.

```{r total-features-hist, fig.cap = "Histogram of the number of detected genes in all cells"}
hist(
    umi$total_features,
    breaks = 100
)
abline(v = 7000, col = "red")
```

Here we see that most cells have between 7,000-10,000 detected genes,
which is normal for high-depth scRNA-seq. However this varies by
experimental protocol and sequencing depth with droplet-based methods
or lower sequencing-depth detecting fewer genes per cell. The feature
to note is the __"heavy tail"__ of the left hand side of the
distribution. If detection rates were equal across the cells then the
distribution should be approximately normal. Thus we remove those
cells in the tail of the distribution (<7,000 detected genes).

```{r}
filter_by_expr_features <- (umi$total_features > 7000)
```

```{r}
knitr::kable(
    as.data.frame(table(filter_by_expr_features)),
    booktabs = TRUE,
    row.names = FALSE,
    caption = 'The number of cells removed by total features filter (FALSE)'
)
```
### ERCCs and MTs

Another measures of cell quality is the ration between ERCC _spike-in_
RNAs and endogenous RNAs. This can be used to estimate the total amount
of RNA in the captured cells. Cells with a high level of _spike-in_ RNAs
had low starting amounts of RNA, likely due to the cell being
dead or stressed, or the RNA being degraded.

```{r mt-vs-counts, fig.cap = "Percentage of counts in MT genes"}
scater::plotPhenoData(
    umi,
    aes_string(x = "total_features",
               y = "pct_counts_feature_controls_MT",
               colour = "batch")
)
```

```{r ercc-vs-counts, fig.cap = "Percentage of counts in ERCCs"}
scater::plotPhenoData(
    umi,
    aes_string(x = "total_features",
               y = "pct_counts_feature_controls_ERCC",
               colour = "batch")
)
```

This analysis shows that majority of the cells from NA19098.r2 batch have a very high ERCC/Endo ratio. Indeed, it has been shown by the authors that this batch contains cells of smaller size. 

__Exercise__

Create filters for removing batch NA19098.r2 and cells with high expression of mitochondrial genes (>10% of total counts in a cell).

__Answer__

```{r}
filter_by_ERCC <- umi$batch != "NA19098.r2"
```
```{r}
knitr::kable(
  as.data.frame(table(filter_by_ERCC)),
  booktabs = TRUE,
  row.names = FALSE,
  caption = 'The number of cells removed by ERCC filter (FALSE)'
)
```
```{r}
filter_by_MT <- umi$pct_counts_feature_controls_MT < 10
```
```{r}
knitr::kable(
  as.data.frame(table(filter_by_MT)),
  booktabs = TRUE,
  row.names = FALSE,
  caption = 'The number of cells removed by MT filter (FALSE)'
)
```

__Exercise__

What would you expect to see in the ERCC vs counts plot if you were examining a dataset containing cells of different sizes (eg. normal & senescent cells)?

__Answer__

You would expect to see a group corresponding to the smaller cells (normal) above a separate group corresponding to the larger cells (senescent).


## Cell filtering

### Default

By default scater will use 5-times the median absolute deviations _(How is "deviation" defined?)_ from the median value as a threshold to filter cells according to the number of detected genes, total counts and percent of counts assigned to control genes _(is this true? It seems odd that they would use a different method for this measure than the other)_ . In addition to any cells that have been marked as controls.

```{r}
umi$use_default <- (
    # remove cells with unusual numbers of genes
    !umi$filter_on_total_features &
    # sufficient molecules counted
    !umi$filter_on_total_counts &
    # sufficient endogenous RNA
    !umi$filter_on_pct_counts_feature_controls_ERCC &
    # remove cells with unusual number of reads in MT genes
    !umi$filter_on_pct_counts_feature_controls_MT &
    # controls shouldn't be used in downstream analysis
    !umi$is_cell_control
)
```

```{r}
knitr::kable(
  as.data.frame(table(umi$use_default)),
  booktabs = TRUE,
  row.names = FALSE,
  caption = 'The number of cells removed by default filter (FALSE)'
)
```

### Automatic

Another option available in __scater__ is to conduct PCA on a set of QC metrics and then use automatic outlier detection to identify potentially problematic cells. 

By default, the following metrics are used for PCA-based outlier detection:

* __pct_counts_top_100_features__
* __total_features__
* __pct_counts_feature_controls__
* __n_detected_feature_controls__
* __log10_counts_endogenous_features__
* __log10_counts_feature_controls__

```{r auto-cell-filt, fig.align='center', fig.cap="PCA plot used for automatic detection of cell outliers", message=FALSE, warning=FALSE, out.width='90%'}
umi <-
scater::plotPCA(umi,
                size_by = "total_features", 
                shape_by = "filter_on_total_features",
                pca_data_input = "pdata",
                detect_outliers = TRUE,
                return_SCESet = TRUE)
```

```{r}
knitr::kable(
  as.data.frame(table(umi$outlier)),
  booktabs = TRUE,
  row.names = FALSE,
  caption = 'The number of cells removed by automatic filter (FALSE)'
)
```

### Manual

However, since we performed a more detailed analysis, visualized different features and defined our own filters we can use them instead of the default ones:

```{r}
umi$use <- (
    # sufficient features (genes)
    filter_by_expr_features &
    # sufficient molecules counted
    filter_by_total_counts &
    # sufficient endogenous RNA
    filter_by_ERCC &
    # remove cells with unusual number of reads in MT genes
    filter_by_MT
)
```

```{r}
knitr::kable(
  as.data.frame(table(umi$use)),
  booktabs = TRUE,
  row.names = FALSE,
  caption = 'The number of cells removed by manual filter (FALSE)'
)
```

## Compare filterings

__Exercise__

Compare the default, automatic and manual cell filters. Plot a Venn diagram of the outlier cells from these filterings.

__Hint__: Use `limma::vennCounts` and `limma::vennDiagram` functions from the [limma](https://bioconductor.org/packages/release/bioc/html/limma.html) package to make a Venn diagram.

__Answer__

```{r cell-filt-comp, fig.cap = "Comparison of the default, automatic and manual cell filters"}
def <- colnames(umi)[!umi$use_default]
auto <- colnames(umi)[umi$outlier]
man <- colnames(umi)[!umi$use]
venn.diag <- limma::vennCounts(cbind(colnames(umi) %in% def,
                                     colnames(umi) %in% auto,
                                     colnames(umi) %in% man))
limma::vennDiagram(venn.diag,
                   names = c("Default", "Automatic", "Manual"),
                   circle.col = c("magenta", "blue", "green"))
```

## Gene filtering

### Gene expression

One can also look at the number of reads consumed by the top 50 expressed genes.

```{r top50-gene-expr, fig.cap = "Number of total counts consumed by the top 50 expressed genes", fig.asp = 1}
scater::plotQC(umi, type = "highest-expression")
```

The distribution relatively flat indicating good coverage of the full transcriptome of these cell.


## Gene filtering

We can remove genes whose expression level is considered __"undetectable"__. We define a detectable gene expression level, in which at least two cells contain more than 1 read mapping to the gene. If we were considering read counts rather than UMI counts typically at least five reads in at least two cells is considered the threshold for detectability. Note that genes must be filtered after cell filtering since some genes may be only detected in poor quality cells.

```{r}
filter_genes <- apply(counts(umi), 1, function(x) length(x[x > 1]) >= 2)
fData(umi)$use <- filter_genes
```

```{r}
knitr::kable(
    as.data.frame(table(filter_genes)),
    booktabs = TRUE,
    row.names = FALSE,
    caption = 'The number of genes removed by gene filter (FALSE)'
)
```

Depending on the cell-type, protocol and sequencing depth, other cut-offs may be appropriate.


## Save the data

Dimensions of the QCed dataset (do not forget about the gene filter we defined above):
```{r}
dim(umi[fData(umi)$use, pData(umi)$use])
```

Save the data:
```{r}
saveRDS(umi, file = "blischak/umi.rds")
```

## Exercise

Perform exactly the same QC analysis with read counts of the same Blischak data. Use `blischak/reads.txt` file to load the reads. Once you have finished please compare your results to ours (next chapter).
